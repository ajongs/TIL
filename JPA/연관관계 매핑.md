객체와 테이블의 연관관계 차이

객체의 참조와 테이블의 외래 키 매핑 차이를 이해하자.

외래키값을 그대로 가져오면 객체지향의 패러다임이 지켜지지 않음
왜? 참조값이 없기 때문에.(연결이 끊김) 
다시 외래키(식별자) 값으로 team을 가져와야함


단방향 연관관계
@ManyToOne
@JoinColumn(name=“”)

지금까지 짜온 관계는 양쪽으로 매핑이 안됨.
하지만 데이터베이스에서는 조인으로 team에서도 member을 알 수 있음


다쪽이 연관관계 주인이 되면 된다.
1쪽이 주인이 되면 다른테이블이 변경되는 사태가 생길 수 있다. 뭔가 이상함.


### 양방향 매핑 시 주의할점.

1. 다쪽에만 연관관계를 명시/설정 해줄 때
ex) team.getMembers().add(member);
—> 데이터베이스에서 member의 team id는 null
—> jpa는 member의 team id를 변경/수정을 반영할 때 member의 team 필드를 참조하는데
      객체에서 초기화를 안해줬기 때문

2. 그럼 연관관계 주인한테만 관계를 명시하면 되냐?
—> DB에 넣고 트랜잭션 종료 후 or em.flush(), em.clear() 후 영속성 컨텍스트가 비어있을 때,
 member나 team을 디비에서 다시 영속성 컨텍스트로 불러와서 조회 시는 문제없음.
—> 하지만 1차캐시에 반영만 했을 때는 team의 members가 null인 문제가 있음
결론, member.setTeam(team); , team.getMembers().add(member); 둘다 해주는게 맞음.
순수 객체 상태를 고려하자. —> 테스트케이스에서도 활용가능

둘다 해주는 것을 깜빡한다거나 귀찮다면 setTeam 메소드에 추가를 해놔서 자동으로 호출되게 하자.

3. 무한 루프에 조심하자
toString() 경우 서로를 참조하고 있기때문에 member에서 team , team에서 members 무한으로 toString() 호출 된다.
lombok에서는 toString()을 쓰지말자.
JSON에서는 컨트롤러에서 반환할때 ResponseEntity 자체를 반환하지 말고 DTO 같이 값만 들어있는 임시 객체만들어서 반환하자. 
이러면 무한루프도 해결할 수 있지만, api의 내부변수가 생성되거나 할 때 api스펙이 바뀌는 것을 예방할 수 있다.

객체 입장에서 양방향 매핑 설계는 사실 좋지는 않음. 해결해야될 문제가 많기 때문에.
그래서 단방향 매핑으로 설계는 다 마치고 꼭 필요 할 때만 양방향 매핑을 나중에 추가하자.
어차피 양방향 매핑은 테이블에 영향을 미치지 않는다. jpa도 연관관계 주인만 이용해서 변화를 파악하고 쿼리를 날리기 때문에 상관 X.

연관관계 주인은 외래 키 위치를 기준으로 정해야함. 외래키가 있는 곳이 주인.
